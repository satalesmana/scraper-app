import path, { resolve, dirname, isAbsolute, relative } from 'node:path';
import { useNuxt, logger, defineNuxtModule, createResolver, resolvePath, addPlugin, addPluginTemplate, addComponent, addImports, addImportsSources } from '@nuxt/kit';
import os from 'node:os';
import { readFile } from 'node:fs/promises';
import pMemoize from 'p-memoize';
import MagicString from 'magic-string';
import { loadFile, builders, generateCode } from 'magicast';
import { getDefaultExportOptions } from 'magicast/helpers';

const version = "2.0.8";

const isWindows = os.platform() === "win32";
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return path.posix.normalize(isWindows ? slash(id) : id);
}
function omit(object, keys) {
  return Object.keys(object).reduce((output, key) => {
    if (!keys.includes(key)) {
      output[key] = object[key];
    }
    return output;
  }, {});
}
const readFileMemoized = pMemoize(async (path2) => {
  return readFile(path2, "utf-8");
});
const readJSON = pMemoize(async (path2) => {
  return JSON.parse(await readFile(path2, "utf-8"));
});
const PASCAL_CASE = /[a-z][A-Z]|^[A-Z]/g;
function kebabCase(string) {
  return string.replaceAll(
    PASCAL_CASE,
    (match) => match.length === 1 ? match[0].toLowerCase() : `${match[0]}-${match[1].toLowerCase()}`
  );
}
const FS_PREFIX = "/@fs";
const VOLUME_RE = /^[A-Z]:/i;
const POSTFIX_RE = /[?#].*$/s;
function cleanUrl(url) {
  return url.replace(POSTFIX_RE, "");
}
function fsPathFromId(id) {
  const fsPath = normalizePath(
    id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id
  );
  return fsPath[0] === "/" || fsPath.match(VOLUME_RE) ? fsPath : `/${fsPath}`;
}
function fsPathFromUrl(url) {
  return fsPathFromId(cleanUrl(url));
}
function hasKeys(object) {
  return Object.keys(object || {}).length > 0;
}
function parseVueRequest(id) {
  const [filename, rawQuery] = id.split("?", 2);
  const query = Object.fromEntries(new URLSearchParams(rawQuery));
  if (query.vue != null) {
    query.vue = true;
  }
  return {
    filename,
    query
  };
}
function uniq(arr) {
  return [...new Set(arr)];
}

function when(condition, content) {
  return condition ? typeof content === "function" ? content() : content : "";
}
function vuePluginTemplate(context, ssr) {
  const isServer = context.mode === "server";
  const isClient = !isServer;
  const plugins = uniq(context.options.plugins || []);
  const { config, lang, iconSet } = context.options;
  return `import { ref, computed, useHead } from "#imports"
import { defineNuxtPlugin } from "#app"
import Quasar from "quasar/src/vue-plugin.js"
${plugins.map((plugin) => `import ${plugin} from "quasar/${context.imports.raw[plugin]}"`).join("\n") || ""}
${when(lang, () => `import lang from "quasar/lang/${lang}"`)}
${when(typeof iconSet === "string", () => `import iconSet from "quasar/icon-set/${iconSet}"`)}

export default defineNuxtPlugin((nuxt) => {
${when(isServer, () => `  const ssrContext = {
    req: nuxt.ssrContext.event.req,
    res: nuxt.ssrContext.event.res,
  }`)}
${when(ssr && isClient, () => `  const NuxtPlugin = {
    install({ onSSRHydrated }) {
      nuxt.hook("app:suspense:resolve", () => {
        onSSRHydrated.forEach(fn => fn())
      })
    }
  }`)}
${when(ssr && isServer, () => `
  const bodyClasses = ref("")
  const htmlAttrs = ref("")

  const htmlAttrsRecord = computed(() => {
    return Object.fromEntries(
      htmlAttrs.value
        .split(" ")
        .map(attr => attr.split("="))
    )
  })

  useHead(computed(() => ({
    bodyAttrs: {
      class: bodyClasses.value
    },
    htmlAttrs: htmlAttrsRecord.value,
  })))

  const NuxtPlugin = {
    install({ ssrContext }) {
      bodyClasses.value = ssrContext._meta.bodyClasses
      htmlAttrs.value = ssrContext._meta.htmlAttrs
      ssrContext._meta = new Proxy({}, {
        get(target, key) {
          if (key === "bodyClasses") {
            return bodyClasses.value
          } else if (key === "htmlAttrs") {
            return htmlAttrs.value
          } else {
            return target[key]
          }
        },
        set(target, key, value) {
          if (key === "bodyClasses") {
            bodyClasses.value = value
          } else if (key === "htmlAttrs") {
            htmlAttrs.value = value
          } else {
            target[key] = value
          }
          return true
        }
      })
    }
  }`)}

  nuxt.vueApp.use(Quasar, {
    ${when(lang, "lang,")}
    ${typeof iconSet === "string" ? "iconSet" : `iconSet: ${iconSet ? JSON.stringify(iconSet) : "material-icons"}`},
    plugins: {${when(ssr, "NuxtPlugin, ") + (plugins.join(",") || "")}},
    ${when(config, () => `config: ${JSON.stringify(omit(context.options.config || {}, ["brand"]))},`)}
  }${when(isServer, ", ssrContext")})
})`;
}

const directivesRegExp = /(?<=[ (])_?resolveDirective\(\s*["']([^'"]*?)["'][\s,]*[^)]*\)/g;
function transformDirectivesPlugin(context) {
  const { sourcemap } = useNuxt().options;
  return {
    name: "quasar:directive",
    enforce: "post",
    transform(code, id) {
      const [filename] = id.split("?", 2);
      if (!filename.endsWith(".vue"))
        return null;
      const s = new MagicString(code);
      const directives = [];
      let counter = 0;
      s.replace(directivesRegExp, (full, name) => {
        const directive = context.imports.directives.find((d) => d.kebabCase === name);
        if (directive) {
          const alias = `__q_directive_${counter++}`;
          directives.push({
            alias,
            path: directive.path
          });
          return alias;
        } else {
          return full;
        }
      });
      if (directives.length) {
        s.prepend(
          `${directives.map((d) => `import ${d.alias} from "${d.path}"`).join("\n")}
`
        );
      }
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: sourcemap[context.mode] ? s.generateMap({ source: id, includeContent: true }) : void 0
        };
      }
    }
  };
}

function transformScssPlugin({ options }) {
  const sassVariables = typeof options.sassVariables === "string" ? normalizePath(options.sassVariables) : options.sassVariables;
  const scssTransform = createScssTransform("scss", sassVariables);
  const sassTransform = createScssTransform("sass", sassVariables);
  return {
    name: "quasar:scss",
    enforce: "pre",
    transform(src, id) {
      const { filename, query } = parseVueRequest(id);
      let code;
      if (query.vue && query.type === "style") {
        const lang = Object.keys(query).find((k) => k.startsWith("lang."));
        if (lang?.endsWith(".scss")) {
          code = scssTransform(src);
        } else if (lang?.endsWith(".sass")) {
          code = sassTransform(src);
        }
      }
      if (!query.vue) {
        if (filename.endsWith(".scss")) {
          code = scssTransform(src);
        } else if (filename.endsWith(".sass")) {
          code = sassTransform(src);
        }
      }
      if (code) {
        return { code, map: null };
      }
    }
  };
}
function createScssTransform(fileExtension, sassVariables) {
  const sassImportCode = ["@import 'quasar/src/css/variables.sass'", ""];
  if (typeof sassVariables === "string") {
    sassImportCode.unshift(`@import '${sassVariables}'`);
  }
  const prefix = fileExtension === "sass" ? sassImportCode.join("\n") : sassImportCode.join(";\n");
  return (content) => {
    const useIndex = Math.max(
      content.lastIndexOf("@use "),
      content.lastIndexOf("@forward ")
    );
    if (useIndex === -1) {
      return prefix + content;
    }
    const newLineIndex = content.indexOf("\n", useIndex);
    if (newLineIndex !== -1) {
      const index = newLineIndex + 1;
      return content.substring(0, index) + prefix + content.substring(index);
    }
    return `${content}
${prefix}`;
  };
}

const QUASAR_ENTRY = "quasar";
const QUASAR_VIRTUAL_ENTRY = "/__quasar/entry.mjs";
function virtualQuasarEntryPlugin(context) {
  return {
    name: "quasar:entry",
    enforce: "pre",
    resolveId(id) {
      if (id === QUASAR_ENTRY) {
        return {
          id: QUASAR_VIRTUAL_ENTRY,
          moduleSideEffects: false
        };
      }
    },
    async load(id) {
      if (id === QUASAR_VIRTUAL_ENTRY)
        return Object.entries(context.imports.raw).filter(([, path]) => !path.includes("/__tests__/")).map(([name, path]) => `export { default as ${name} } from "quasar/${path}"`).join("\n");
    }
  };
}

const quasarFontsPath = "quasar/fonts";
const quasarAnimationsPath = "quasar/animations";
const quasarIconsPath = "quasar/icons";
const quasarCssPath = "quasar/css";
const quasarBrandPath = "quasar/brand";

const RESOLVED_ID$1 = "/__quasar/animations.css";
const RESOLVED_ID_WITH_QUERY_RE$1 = /([\/\\])__quasar\1animations\.css(\?.*)?$/;
function virtualAnimationsPlugin({ options, resolveQuasarExtras }) {
  return {
    name: "quasar:animations",
    resolveId(id) {
      if (id.match(RESOLVED_ID_WITH_QUERY_RE$1))
        return id;
      const [path] = id.split("?");
      if (path === quasarAnimationsPath)
        return RESOLVED_ID$1;
    },
    async load(id) {
      if (!RESOLVED_ID_WITH_QUERY_RE$1.test(id))
        return;
      let animations = options.extras?.animations || [];
      if (animations === "all") {
        const { generalAnimations, inAnimations, outAnimations } = await import('@quasar/extras/animate/animate-list.mjs');
        animations = [...generalAnimations, ...inAnimations, ...outAnimations];
      } else {
        animations = uniq(animations);
      }
      return animations.map((animation) => `@import '${resolveQuasarExtras(`animate/${animation}.css`)}';`).join("\n");
    }
  };
}

const RESOLVED_ID = "/__quasar/brand.css";
const RESOLVED_ID_WITH_QUERY_RE = /([\/\\])__quasar\1brand\.css(\?.*)?$/;
function virtualBrandPlugin(context) {
  return {
    name: "quasar:brand",
    resolveId(id) {
      if (id.match(RESOLVED_ID_WITH_QUERY_RE))
        return id;
      const [path] = id.split("?");
      if (path === quasarBrandPath)
        return RESOLVED_ID;
    },
    load(id) {
      if (RESOLVED_ID_WITH_QUERY_RE.test(id))
        return [
          ":root {",
          ...Object.entries(context.options.config?.brand || {}).map(([name, color]) => `  --q-${name}: ${color};`),
          "}"
        ].join("\n");
    }
  };
}

const QUASAR_COMPONENT_RE = /(?:([\\\/])node_modules\1|^)quasar(?=\1)([\\\/])src\2components\2[a-z-]+?\2(Q[a-zA-Z]+?)\.js(\?.*)?$/;
const QUASAR_COMPONENT_WITH_DEFAULTS_PREFIX = "/__quasar/components";
const QUASAR_IMPORT_RE = /([\\\/])node_modules\1quasar\1src\1/;
const MERGE_FN = "__merge__";
const DEFAULT_FN = "__default__";
const VALUES_FN = "__values__";
function transformDefaultsPlugin(context) {
  const loadCache = /* @__PURE__ */ new Map();
  const resolveMetadata = /* @__PURE__ */ new Map();
  const deepDefaultsEnabled = context.options.components?.deepDefaults || false;
  return {
    name: "quasar:defaults",
    resolveId: {
      order: "pre",
      async handler(source, importer, options) {
        const isRelative = source.startsWith(".");
        if (isRelative && importer?.startsWith(QUASAR_COMPONENT_WITH_DEFAULTS_PREFIX)) {
          const { originalPath } = resolveMetadata.get(importer);
          return resolve(dirname(originalPath), source);
        }
        if (deepDefaultsEnabled) {
          if (importer?.match(QUASAR_IMPORT_RE) && isAbsolute(importer)) {
            source = resolve(dirname(importer), source);
          }
        }
        const match = source.match(QUASAR_COMPONENT_RE);
        if (match) {
          const resolution = await this.resolve(source, importer, {
            ...options,
            skipSelf: true
          });
          const name = match[3];
          const defaults = context.options.components?.defaults?.[name];
          if (resolution && defaults) {
            const originalPath = fsPathFromUrl(
              resolution.id.startsWith("quasar/") ? context.resolveQuasar(resolution.id.slice("quasar/".length)) : resolution.id
            );
            resolution.id = `${QUASAR_COMPONENT_WITH_DEFAULTS_PREFIX}/${name}.js`;
            resolution.external = false;
            if (!resolveMetadata.has(resolution.id)) {
              resolveMetadata.set(resolution.id, {
                name,
                defaults,
                originalPath
              });
            }
          }
          return resolution;
        }
      }
    },
    load(id) {
      if (id.startsWith(QUASAR_COMPONENT_WITH_DEFAULTS_PREFIX)) {
        if (loadCache.has(id)) {
          return loadCache.get(id);
        } else {
          const metadata = resolveMetadata.get(id);
          const promise = loadComponentWithDefaults(metadata, context).catch(async (err) => {
            const code = await readFile(metadata.originalPath, "utf-8");
            logger.error(`Failed to apply defaults to component ${metadata.name}.`, err);
            return { code };
          });
          loadCache.set(id, promise);
          return promise;
        }
      }
    }
  };
}
function isValidConstructor(type) {
  return !["null", "undefined", "Any"].includes(type);
}
function createPropOptions(context, metadata, defaultValue) {
  const options = {};
  if (metadata.extends) {
    metadata = context.extended.props[metadata.extends];
  }
  if (Array.isArray(metadata.type)) {
    const types = metadata.type.filter(isValidConstructor).map((t) => builders.raw(t));
    if (types.length > 0) {
      options.type = types;
    }
  } else if (isValidConstructor(metadata.type)) {
    options.type = builders.raw(metadata.type);
  }
  if (metadata.required) {
    options.required = metadata.required;
  }
  if (typeof defaultValue === "object") {
    context.imports.add(DEFAULT_FN);
    options.default = builders.functionCall(DEFAULT_FN, defaultValue);
  } else {
    options.default = defaultValue;
  }
  if (metadata.values) {
    context.imports.add(VALUES_FN);
    options.validator = builders.functionCall(VALUES_FN, metadata.values);
  }
  return options;
}
async function getPropMetadata(context, metadata, componentName, propName) {
  const propMetadata = metadata.props?.[propName];
  if (propMetadata) {
    return propMetadata;
  } else if (metadata.mixins?.length) {
    for (const mixin of metadata.mixins) {
      const mixinMetadata = await readJSON(resolve(context.sourcePath, `${mixin}.json`));
      const propMetadata2 = await getPropMetadata(context, mixinMetadata, componentName, propName);
      if (propMetadata2)
        return propMetadata2;
    }
  }
  throw new Error(`Unknown ${componentName} prop: [${propName}]`);
}
function assertDefaults(defaults) {
  for (const value of Object.values(defaults)) {
    if (typeof value === "function")
      throw new TypeError("Component defaults does not support default values that are functions");
  }
}
async function loadComponentWithDefaults({ name: componentName, defaults, originalPath }, { resolveLocal, resolveQuasar }) {
  assertDefaults(defaults);
  const module = await loadFile(originalPath);
  const magicastUtils = resolveLocal("runtime/magicastUtils");
  const sourcePath = resolveQuasar("src");
  const componentRelativePath = relative(sourcePath, originalPath).slice(0, -".js".length);
  const componentDefaultEntries = Object.entries(defaults);
  const componentOptions = getDefaultExportOptions(module);
  const componentMetadata = await readJSON(resolve(sourcePath, `${componentRelativePath}.json`));
  const apiExtends = await readJSON(resolveQuasar("src/api.extends.json"));
  const buildContext = {
    imports: /* @__PURE__ */ new Set(),
    extended: apiExtends,
    sourcePath
  };
  if (componentOptions.props.$type === "identifier") {
    buildContext.imports.add(MERGE_FN);
    const newPropOptions = await Promise.all(
      componentDefaultEntries.map(async ([propName, defaultValue]) => {
        const propMetadata = await getPropMetadata(buildContext, componentMetadata, componentName, kebabCase(propName));
        const propOptions = createPropOptions(buildContext, propMetadata, defaultValue);
        return {
          name: propName,
          options: propOptions
        };
      })
    );
    componentOptions.props = builders.functionCall(
      MERGE_FN,
      componentOptions.props,
      Object.fromEntries(
        newPropOptions.map((r) => [r.name, r.options])
      )
    );
  } else if (componentOptions.props.$type === "object") {
    const componentProps = componentOptions.props;
    for (let [propName, defaultValue] of componentDefaultEntries) {
      const propOptions = componentProps[propName];
      if (propOptions) {
        if (typeof defaultValue === "object") {
          buildContext.imports.add(DEFAULT_FN);
          defaultValue = builders.functionCall(DEFAULT_FN, defaultValue);
        }
        if (propOptions.$type === "object") {
          propOptions.default = defaultValue;
        } else if (propOptions.$type === "array" || propOptions.$type === "identifier") {
          componentProps[propName] = {
            type: propOptions,
            default: defaultValue
          };
        } else {
          throw new Error(`Unexpected prop definition type used at ${componentName}.props.${propName}, please open an issue.`);
        }
      } else {
        const propMetadata = await getPropMetadata(buildContext, componentMetadata, componentName, kebabCase(propName));
        const propOptions2 = createPropOptions(buildContext, propMetadata, defaultValue);
        componentProps[propName] = propOptions2;
      }
    }
  } else {
    throw new Error(`Unexpected props definition type used at ${componentName}.props, please open an issue.`);
  }
  for (const imported of buildContext.imports) {
    module.imports.$add({
      from: magicastUtils,
      imported
    });
  }
  return generateCode(module);
}

function setupCss(css, options) {
  const brand = options.config?.brand || {};
  if (!css.includes(quasarBrandPath) && Object.keys(brand).length) {
    css.unshift(quasarBrandPath);
  }
  const quasarCss = [
    options.sassVariables ? "quasar/src/css/index.sass" : "quasar/dist/quasar.css"
  ];
  if (options.cssAddon) {
    quasarCss.push("quasar/src/css/flex-addon.sass");
  }
  const index = css.indexOf(quasarCssPath);
  if (index !== -1) {
    css.splice(index, 1, ...quasarCss);
  } else {
    css.unshift(...quasarCss);
  }
  const animations = options.extras?.animations || [];
  if (!css.includes(quasarAnimationsPath) && animations.length) {
    css.unshift(quasarAnimationsPath);
  }
  if (options.extras?.fontIcons) {
    const i = css.indexOf(quasarIconsPath);
    if (i !== -1) {
      css.splice(i, 1, ...uniq(options.extras.fontIcons).map(resolveFontIcon));
    } else {
      css.unshift(...uniq(options.extras.fontIcons).map(resolveFontIcon));
    }
  }
  if (options.extras?.font) {
    const i = css.indexOf(quasarFontsPath);
    if (i !== -1) {
      css.splice(i, 1, resolveFont(options.extras.font));
    } else {
      css.unshift(resolveFont(options.extras.font));
    }
  }
  return css;
}
function resolveFontIcon(icon) {
  return `@quasar/extras/${icon}/${icon}.css`;
}
function resolveFont(font) {
  return `@quasar/extras/${font}/${font}.css`;
}

function enableQuietSassWarnings(config) {
  var _a;
  const silenceSomeSassDeprecationWarnings = {
    verbose: true,
    logger: {
      warn(logMessage, logOptions) {
        const { stderr } = process;
        const span = logOptions.span ?? void 0;
        const stack = (logOptions.stack === "null" ? void 0 : logOptions.stack) ?? void 0;
        if (logOptions.deprecation) {
          if (logMessage.startsWith("Using / for division outside of calc() is deprecated")) {
            return;
          }
          stderr.write("DEPRECATION ");
        }
        stderr.write(`WARNING: ${logMessage}
`);
        if (span !== void 0) {
          stderr.write(`
"${span.text}"
`);
        }
        if (stack !== void 0) {
          stderr.write(`    ${stack.toString().trimEnd().replace(/\n/gm, "\n    ")}
`);
        }
        stderr.write("\n");
      }
    }
  };
  config.css ?? (config.css = {});
  (_a = config.css).preprocessorOptions ?? (_a.preprocessorOptions = {});
  const types = ["scss", "sass"];
  for (const type of types) {
    const userConfig = config.css.preprocessorOptions[type];
    config.css.preprocessorOptions[type] = {
      ...silenceSomeSassDeprecationWarnings,
      ...userConfig
    };
  }
}

const module = defineNuxtModule({
  meta: {
    name: "quasar",
    version,
    configKey: "quasar",
    compatibility: {
      nuxt: "^3.0.0",
      bridge: false
    }
  },
  defaults: {
    lang: "en-US",
    iconSet: "material-icons",
    autoIncludeIconSet: true,
    cssAddon: false,
    sassVariables: false,
    quietSassWarnings: true,
    components: {
      defaults: {},
      deepDefaults: false
    },
    plugins: [],
    extras: {}
  },
  async setup(options, nuxt) {
    var _a;
    const { resolve: resolveLocal } = createResolver(import.meta.url);
    const { resolve: resolveQuasar } = createResolver(dirname(await resolvePath("quasar/package.json")));
    const { resolve: resolveQuasarExtras } = createResolver(dirname(await resolvePath("@quasar/extras/package.json")));
    const { version: quasarVersion } = await readJSON(resolveQuasar("package.json"));
    const importMap = await readJSON(resolveQuasar("dist/transforms/import-map.json"));
    const transformAssetUrls = await readJSON(resolveQuasar("dist/transforms/loader-asset-urls.json"));
    const imports = categorizeImports(importMap, resolveQuasar);
    const baseContext = {
      imports,
      options,
      resolveLocal,
      resolveQuasar,
      resolveQuasarExtras
    };
    if (options.autoIncludeIconSet && typeof options.iconSet === "string" && isFontIconSet(options.iconSet) && !options.extras?.fontIcons?.includes(options.iconSet)) {
      options.extras ?? (options.extras = {});
      (_a = options.extras).fontIcons ?? (_a.fontIcons = []);
      options.extras.fontIcons.push(options.iconSet);
    }
    setupCss(nuxt.options.css, options);
    addPlugin(resolveLocal("./runtime/provide"));
    addPluginTemplate({
      mode: "client",
      filename: "quasar-plugin.mjs",
      getContents: () => vuePluginTemplate({
        ...baseContext,
        mode: "client"
      }, nuxt.options.ssr)
    });
    if (nuxt.options.ssr) {
      addPluginTemplate({
        mode: "server",
        filename: "quasar-plugin.server.mjs",
        getContents: () => vuePluginTemplate({
          ...baseContext,
          mode: "server"
        }, nuxt.options.ssr)
      });
    }
    if (nuxt.options.components !== false) {
      for (const component of imports.components) {
        addComponent({
          name: component.name,
          export: "default",
          filePath: component.path
        });
      }
    }
    if (nuxt.options.imports.autoImport !== false) {
      const ignoredComposables = ["useId", "useHydration"];
      for (const composable of imports.composables.filter((c) => !ignoredComposables.includes(c.name))) {
        addImports({
          name: composable.name,
          from: resolveLocal("./runtime/adapter")
        });
      }
      if (options.plugins) {
        for (const plugin of uniq(options.plugins)) {
          addImports({
            name: plugin,
            from: resolveLocal("./runtime/adapter")
          });
        }
      }
      if (options.extras?.svgIcons) {
        for (const iconSet of uniq(options.extras.svgIcons)) {
          const icons = await getIconsFromIconset(iconSet, resolveQuasarExtras);
          addImportsSources({
            from: `@quasar/extras/${iconSet}`,
            imports: icons
          });
        }
      }
    }
    nuxt.hook("prepare:types", ({ references }) => {
      references.unshift({ types: "quasar" });
    });
    nuxt.hook("vite:extendConfig", (config, { isClient, isServer }) => {
      var _a2, _b, _c;
      const ssr = nuxt.options.ssr;
      const context = {
        ...baseContext,
        mode: isServer ? "server" : "client"
      };
      config.optimizeDeps ?? (config.optimizeDeps = {});
      (_a2 = config.optimizeDeps).exclude ?? (_a2.exclude = []);
      config.optimizeDeps.exclude.push("quasar");
      config.vue ?? (config.vue = {});
      (_b = config.vue).template ?? (_b.template = {});
      if (config.vue.template.transformAssetUrls !== false) {
        (_c = config.vue.template).transformAssetUrls ?? (_c.transformAssetUrls = {});
        config.vue.template.transformAssetUrls = {
          ...config.vue.template.transformAssetUrls,
          ...transformAssetUrls
        };
      }
      config.define = {
        ...config.define,
        __QUASAR_VERSION__: `'${quasarVersion}'`,
        __QUASAR_SSR__: ssr,
        __QUASAR_SSR_SERVER__: ssr && isServer,
        __QUASAR_SSR_CLIENT__: ssr && isClient,
        __QUASAR_SSR_PWA__: false
      };
      if (options.quietSassWarnings) {
        enableQuietSassWarnings(config);
      }
      config.plugins ?? (config.plugins = []);
      config.plugins.push(
        virtualAnimationsPlugin(context),
        virtualBrandPlugin(context),
        transformDirectivesPlugin(context),
        virtualQuasarEntryPlugin(context)
      );
      if (hasKeys(options.components?.defaults)) {
        config.plugins.unshift(
          transformDefaultsPlugin(context)
        );
      }
      if (options.sassVariables) {
        config.plugins.push(transformScssPlugin(context));
      }
    });
    nuxt.hook("nitro:config", async (config) => {
      var _a2;
      config.replace = {
        ...config.replace,
        __QUASAR_VERSION__: `'${quasarVersion}'`,
        __QUASAR_SSR__: nuxt.options.ssr,
        __QUASAR_SSR_SERVER__: true,
        __QUASAR_SSR_CLIENT__: false,
        __QUASAR_SSR_PWA__: false
      };
      config.externals ?? (config.externals = {});
      (_a2 = config.externals).inline ?? (_a2.inline = []);
      config.externals.inline.push(
        resolveQuasar("lang/en-US"),
        resolveQuasar("icon-set/material-icons")
      );
    });
    nuxt.hook("devtools:customTabs", (tabs) => {
      tabs.push({
        name: "quasar",
        title: "Quasar",
        icon: "vscode-icons-file-type-light-quasar",
        view: {
          type: "iframe",
          src: "https://quasar.dev/vue-components"
        }
      });
    });
  }
});
function isFontIconSet(iconSet) {
  return !iconSet.startsWith("svg-");
}
function categorizeImports(importMap, quasarResolve) {
  const imports = {
    raw: importMap,
    components: [],
    composables: [],
    directives: [],
    plugins: []
  };
  for (const [name, path] of Object.entries(importMap)) {
    const importData = {
      name,
      path: quasarResolve(path)
    };
    if (path.includes("/components/") && !path.includes("/__tests__/")) {
      imports.components.push(importData);
    } else if (path.includes("/composables/")) {
      imports.composables.push(importData);
    } else if (path.includes("/directives/")) {
      imports.directives.push({
        ...importData,
        kebabCase: kebabCase(name)
      });
    } else if (path.includes("/plugins/")) {
      imports.plugins.push(importData);
    }
  }
  return imports;
}
const iconDeclarationPattern = /^export declare const ([a-zA-Z\d]+): string;?$/gm;
async function getIconsFromIconset(iconSet, resolveQuasarExtras) {
  try {
    const icons = await readJSON(resolveQuasarExtras(`${iconSet}/icons.json`));
    return icons;
  } catch {
    const path = resolveQuasarExtras(`${iconSet}/index.d.ts`);
    const dts = await readFileMemoized(path);
    const icons = [...dts.matchAll(iconDeclarationPattern)].map((arr) => arr[1]);
    return icons;
  }
}

export { module as default };
