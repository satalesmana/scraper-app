import { logger, createResolver, addTemplate } from '@nuxt/kit';
import { fileURLToPath } from 'node:url';
import { resolvePath } from 'mlly';
import { join, dirname, relative, resolve } from 'pathe';
import { getPort } from 'get-port-please';
import fs from 'node:fs/promises';
import { builtinModules } from 'node:module';
import { stringifyImports } from 'unimport';

function createAddonGlobals(nuxt) {
  let unimport;
  nuxt.hook("imports:context", (context) => {
    unimport = context;
  });
  return {
    name: "nuxt:eslint:import-globals",
    async getConfigs() {
      return {
        configs: [
          "// Set globals from imports registry\n" + JSON.stringify({
            name: "nuxt/import-globals",
            languageOptions: {
              globals: Object.fromEntries((await unimport.getImports()).map((i) => [i.as || i.name, "readonly"]))
            }
          })
        ]
      };
    }
  };
}

async function setupDevToolsIntegration(nuxt) {
  let viewerProcess;
  let viewerPort;
  let viewerUrl;
  nuxt.hook("devtools:customTabs", (tabs) => {
    tabs.push({
      name: "eslint-config",
      title: "ESLint Config",
      icon: "https://raw.githubusercontent.com/eslint/config-inspector/main/app/public/favicon.svg",
      view: viewerUrl ? {
        type: "iframe",
        src: viewerUrl
      } : {
        type: "launch",
        description: "Start ESLint config inspector to analyze the local ESLint configs",
        actions: [
          {
            label: "Launch",
            pending: !!viewerProcess,
            handle: async () => {
              const { startSubprocess } = await import('@nuxt/devtools-kit');
              const inspectorBinPath = join(
                dirname(await resolvePath(
                  "@eslint/config-inspector/package.json",
                  { url: dirname(fileURLToPath(import.meta.url)) }
                )),
                "bin.mjs"
              );
              viewerPort = await getPort({
                portRange: [8123, 1e4],
                random: true
              });
              viewerProcess = startSubprocess(
                {
                  command: "node",
                  args: [inspectorBinPath, "--no-open"],
                  cwd: nuxt.options.rootDir,
                  env: {
                    PORT: viewerPort.toString()
                  }
                },
                {
                  id: "eslint-config-inspector",
                  name: "ESLint Config Viewer"
                },
                nuxt
              );
              nuxt.callHook("devtools:customTabs:refresh");
              const url = `http://localhost:${viewerPort}`;
              for (let i = 0; i < 100; i++) {
                if (await fetch(url).then((r) => r.ok).catch(() => false))
                  break;
                await new Promise((resolve) => setTimeout(resolve, 500));
              }
              await new Promise((resolve) => setTimeout(resolve, 2e3));
              viewerUrl = url;
            }
          }
        ]
      }
    });
  });
}

async function initRootESLintConfig(nuxt, generateConfigPath) {
  const { findUp } = await import('find-up');
  const hasFlatConfig = await findUp(
    [
      "eslint.config.js",
      "eslint.config.mjs",
      "eslint.config.cjs",
      "eslint.config.ts",
      "eslint.config.mts",
      "eslint.config.cts"
    ],
    {
      cwd: nuxt.options.rootDir
    }
  );
  if (hasFlatConfig)
    return;
  const targetPath = join(nuxt.options.rootDir, "eslint.config.mjs");
  let relativeDistPath = relative(nuxt.options.rootDir, generateConfigPath);
  if (!relativeDistPath.startsWith("./") && !relativeDistPath.startsWith("../"))
    relativeDistPath = "./" + relativeDistPath;
  await fs.writeFile(
    targetPath,
    [
      "// @ts-check",
      `import withNuxt from '${relativeDistPath}'`,
      "",
      "export default withNuxt(",
      "  // Your custom configs here",
      ")",
      ""
    ].join("\n"),
    "utf-8"
  );
  logger.success(`ESLint config file created at ${targetPath}`);
  logger.info(`If you have .eslintrc or .eslintignore files, you might want to migrate them to the new config file`);
}

function getDirs(nuxt) {
  const dirs = {
    pages: [],
    composables: [],
    components: [],
    componentsPrefixed: [],
    layouts: [],
    plugins: [],
    middleware: [],
    modules: [],
    servers: [],
    root: [nuxt.options.rootDir],
    src: []
  };
  for (const layer of nuxt.options._layers) {
    const r = (t) => relative(nuxt.options.rootDir, resolve(layer.config.srcDir, t.replace(/^~[/\\]/, "")));
    dirs.src.push(r(""));
    dirs.pages.push(r(nuxt.options.dir.pages || "pages"));
    dirs.layouts.push(r(nuxt.options.dir.layouts || "layouts"));
    dirs.plugins.push(r(nuxt.options.dir.plugins || "plugins"));
    dirs.middleware.push(r(nuxt.options.dir.middleware || "middleware"));
    dirs.modules.push(r(nuxt.options.dir.modules || "modules"));
    dirs.composables.push(r("composables"));
    dirs.composables.push(r("utils"));
    for (const dir of layer.config.imports?.dirs ?? []) {
      if (dir)
        dirs.composables.push(r(dir));
    }
    if (layer.config.components && layer.config.components !== true) {
      const options = Array.isArray(layer.config.components) ? { dirs: layer.config.components } : layer.config.components;
      for (const dir of options.dirs || []) {
        if (typeof dir === "string")
          dirs.components.push(r(dir));
        else if (dir && "path" in dir && typeof dir.path === "string") {
          dirs.components.push(r(dir.path));
          if (dir.prefix)
            dirs.componentsPrefixed.push(r(dir.path));
        }
      }
    } else {
      dirs.components.push(r("components"));
    }
  }
  return dirs;
}

const r = createResolver(import.meta.url);
async function generateESLintConfig(options, nuxt, addons) {
  const importLines = [];
  const configItems = [];
  const configDir = nuxt.options.buildDir;
  const config = {
    standalone: true,
    ...typeof options.config !== "boolean" ? options.config || {} : {}
  };
  importLines.push(
    {
      from: "eslint-flat-config-utils",
      name: "composer"
    },
    {
      from: "eslint-typegen",
      name: "default",
      as: "typegen"
    },
    {
      from: "@nuxt/eslint-config/flat",
      name: "createConfigForNuxt"
    },
    {
      from: "@nuxt/eslint-config/flat",
      name: "defineFlatConfigs"
    },
    {
      from: "@nuxt/eslint-config/flat",
      name: "resolveOptions"
    }
  );
  const basicOptions = {
    features: config,
    dirs: getDirs(nuxt)
  };
  configItems.push(`// Nuxt Configs
createConfigForNuxt(options)`);
  for (const addon of addons) {
    const resolved = await addon.getConfigs();
    if (resolved?.imports)
      importLines.push(...resolved.imports);
    if (resolved?.configs)
      configItems.push(...resolved.configs);
  }
  function relativeWithDot(path) {
    const r2 = relative(configDir, path);
    return r2.startsWith(".") ? r2 : "./" + r2;
  }
  const imports = await Promise.all(importLines.map(async (line) => {
    return {
      ...line,
      from: line.from.match(/^\w+:/) || builtinModules.includes(line.from) ? line.from : relativeWithDot(await r.resolvePath(line.from))
    };
  }));
  return [
    "// ESLint config generated by Nuxt",
    '/// <reference path="./eslint-typegen.d.ts" />',
    "",
    stringifyImports(imports, false),
    "",
    "export { defineFlatConfigs }",
    "",
    `export const configs = composer()`,
    "",
    `export const options = resolveOptions(${JSON.stringify(basicOptions, null, 2)})`,
    ``,
    `configs.append(`,
    configItems.join(",\n\n"),
    `)`,
    "",
    "export function withNuxt(...customs) {",
    "  return configs",
    "    .clone()",
    "    .append(...customs)",
    '    .onResolved(configs => typegen(configs, { dtsPath: new URL("./eslint-typegen.d.ts", import.meta.url), augmentFlatConfigUtils: true }))',
    "}",
    "",
    "export default withNuxt"
  ].join("\n");
}

const ESLINT_CONFIG_DTS = [
  'import type { FlatConfigComposer } from "eslint-flat-config-utils"',
  'import { defineFlatConfigs } from "@nuxt/eslint-config/flat"',
  'import type { NuxtESLintConfigOptionsResolved } from "@nuxt/eslint-config/flat"',
  "",
  "declare const configs: FlatConfigComposer",
  "declare const options: NuxtESLintConfigOptionsResolved",
  "declare const withNuxt: typeof defineFlatConfigs",
  "export default withNuxt",
  "export { withNuxt, defineFlatConfigs, configs, options }"
].join("\n");
async function setupConfigGen(options, nuxt) {
  const {
    autoInit = true
  } = typeof options.config !== "boolean" ? options.config || {} : {};
  const defaultAddons = [
    createAddonGlobals(nuxt)
  ];
  nuxt.hook("prepare:types", ({ declarations }) => {
    declarations.push('/// <reference path="./eslint-typegen.d.ts" />');
  });
  const template = addTemplate({
    filename: "eslint.config.mjs",
    write: true,
    async getContents() {
      const addons = [
        ...defaultAddons
      ];
      await nuxt.callHook("eslint:config:addons", addons);
      return generateESLintConfig(options, nuxt, addons);
    }
  });
  addTemplate({
    filename: "eslint.config.d.mts",
    write: true,
    getContents() {
      return ESLINT_CONFIG_DTS;
    }
  });
  if (autoInit) {
    await initRootESLintConfig(nuxt, template.dst);
  }
  setupDevToolsIntegration(nuxt);
}

export { setupConfigGen };
